
---
title: "Teoretyczne próbkowanie przestrzenne"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{SPAG tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteDepends{Cairo}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---

# Istniej¹cy algorytm próbkowania jednorodnego punktów

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Indeks Distance zdefiniowany jest jako stosunek œredniej odleg³oœci pomiêdzy rzeczywistymi firmami do œredniej odleg³oœci pomiêdzy firmami w za³o¿eniu, ¿e by³yby one roz³o¿one w sposób równomierny na ca³ym obszarze:
$$I_{dist} = \frac{ \frac{1}{k} \sum_{i,j} d(i,j) }{\frac{1}{ \hat{k} }  \sum_{i,j} \hat{d}(i,j) } $$
Przy takim podejœciu niezbêdne jest okreœlenie tego, co oznacza "rozk³ad równomierny na obszarze". W poni¿szym tekœcie postaram siê przedstawiæ obecnie wykorzystywan¹ w tym celu metodê.

## Dane do testów.

Na potrzeby dalszej analizy zostanie wykorzystana nastêpuj¹ca mapa Polski:

```{r, warning=FALSE, message=FALSE, fig.align='center'}
library(SPAG)
n <- 1374
newCoordinateSystem<-"+proj=longlat +datum=WGS84"
region<-spTransform(ShapefilePoland, CRS(newCoordinateSystem))

mapaPolski <- ggplot() +
  geom_polygon(data=region, aes(long, lat, group=group), colour='#808080', fill=NA) +
  theme_nothing() +
  labs(long="longitude", lat="latitude")
mapaPolski
```

## Obecne podejœcie

Równomierne rozmieszczenie punktów na danym obszarze otrzymujê siê poprzez naniesienie kraty punktów o odpowiednim rozmiarze na dany obszar, a nastêpnie zostawienie czêœci wspólnej zbioru punktów i obszaru.

Proces ten mo¿na podzieliæ na trzy etapy. Pierwszym z nich jest wyznaczenie rozmiaru kraty, która pos³u¿y do wyznaczania punktów. W tym celu wyznacza siê stosunek powierzchni ramki ograniczaj¹cej rozwa¿any obszar do powierzchni samego obszaru. Otrzymany stosunek jest nastêpnie wykorzystywany do wyznaczenia rzeczywistej liczby punktów potrzebnych do naniesienia na obszar:

$$ \hat{n}  = \frac{P_{box} }{ P_{area} } \cdot n$$


```{r, message=FALSE, warning=FALSE}
x <- region
bb = bbox(region)

getArea = function(x) {
    getAreaPolygons = function(x) {
      holes = unlist(lapply(x@Polygons, function(x) x@hole))
      areas = unlist(lapply(x@Polygons, function(x) x@area))
      area = ifelse(holes, -1, 1) * areas
      area
    }
    sum(unlist(lapply(region@polygons, getAreaPolygons)))
}
  
  area = getArea(x)
  res <- NULL
  bb.area = (bb[1,2]-bb[1,1]) * (bb[2,2]-bb[2,1]) 
  print( paste("Obszar ramki wynosi:", bb.area))
  n_tot = round(n * bb.area/area) 
  print( paste("Rzeczywista liczba nanoszonych punktów wynosi:",n_tot))
```

W drugim etapie wyznaczana jest siatka punktów, która jest nastêpnie nanoszona na obszar. W tym celu niezbêdne jest wyliczenie d³ugoœci boku wycinka kraty:

$$ c = \sqrt{ \frac{P_{box} }{\hat{n}} } = \sqrt{  P_{box} \cdot\frac{P_{area} }{ P_{box} \cdot n} }=\sqrt{  \frac{P_{area} }{n } }$$

znaj¹c ju¿ rozmiar wycinka siatki niezbêdne jest umiejscowienie jej na dany obszar. Domyœlnie, rysowanie siatki rozpoczyna siê od umieszczenia jej w lewym dolnym rogu, a nastêpnie przesuniêciu jej o losowy wektor o dodatnich wspó³rzêdnych.

```{r, message=FALSE, warning=FALSE}
  offset = runif(2)
  pw =0.5 
  nsig <- 20
  cellsize = (prod(apply(bb, 1, diff))/n_tot) ^ pw 
  cellsize = min(cellsize, min(apply(bb, 1, diff)))
  cellsize = rep(cellsize, nrow(bb))
  min.coords = pmax(bb[,1], signif(bb[,1] + offset * cellsize, nsig)) # nsig =20
  expand.grid.arglist = list()
  
  for (i in 1:nrow(bb)) {
    name = paste("x", i, sep = "")
    sign = ifelse(min.coords[i] < bb[i,2], 1, -1) # sprawdzenie jeszcze raz kierunku
    expand.grid.arglist[[name]] = seq(min.coords[i], bb[i,2], sign * cellsize[i])
  }
  
  xy = do.call(expand.grid, expand.grid.arglist)
  attr(xy, "cellsize") = cellsize
  mapaPolski + geom_point(data=xy, aes(x1,x2))
```

W ostatnim etapie odcinane s¹ punkty, które nie nale¿¹ do rozwa¿anej powierzchnii:

```{r, message=FALSE, warning=FALSE}
 sel = xy[,1] >= bb[1,1] & xy[,1] <= bb[1,2] & 
    xy[,2] >= bb[2,1] & xy[,2] <= bb[2,2]
  xy = xy[sel,, drop = FALSE]
  rownames(xy) = NULL
  pts <- SpatialPoints(xy, CRS(proj4string(x)))
  Over_pts_x <- over(pts, geometry(x))
  
  Not_NAs <- !is.na(Over_pts_x)
  res <- pts[Not_NAs]
  res <- as.data.frame(res)
  mapaPolski + geom_point(data=res, aes(x1,x2))

```

## Deterministycznoœæ

Fakt, ¿e ostateczne umieszczenie siatki jest dokonywane w sposób losowy implikuje zmienn¹ liczbê punktów, które zostan¹ naniesione na rozwa¿an¹ powierzchniê. To z kolei powoduje, ¿e wyliczana wartoœæ indeksu Distance równie¿ nie bêdzie deterministyczna. W celu usuniêcia tej zmiennoœci w kolejnych implementacjach funkcji SPAG przesuniêcie losowe ustawiane jest na sta³¹ wartoœæ 0.